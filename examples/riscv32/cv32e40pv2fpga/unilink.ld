/* X-Heep/CV32E40Pv2 linker script

   Copyright (C) 2014-2018 Free Software Foundation, Inc.
   Copyright (C) 2019 ETH ZÃ¼rich and University of Bologna
   Copyright (C) 2024 Embecosm <www.embecosm.com>

   SPDX-License-Identifier: GPL-3.0-or-later

   This linker script is derived from the linker script generated by X-Heep.
   This in turn is based on the standard linker script of the RISC-V GNU
   linker.

   We have stripped out a lot of redundant content, which seems to have left
   here for lack of understanding.
   - there is no support for dynamic linking
   - there is no support for thread local storage (this is a bare metal world)
   - there is no .init or .fini section
   - there is no
*/

OUTPUT_FORMAT("elf32-littleriscv")
OUTPUT_ARCH(riscv)
ENTRY(_start)

/* Combined memory for code and data */
MEMORY
{
  ram (rwxai) : ORIGIN = 0x00000000, LENGTH = 0x00018000
}

/*
 * This linker script tries to put both data and code in ram.
*/

SECTIONS
{
  /* we want a fixed entry point */
  PROVIDE(__boot_address = 0x180);

  /* interrupt vectors */
  .vectors (ORIGIN(ram)):
  {
    PROVIDE(__vector_start = .);
    KEEP(*(.vectors));
  } >ram

  /* crt0 init code */
  .init (__boot_address):
  {
    KEEP (*(SORT_NONE(.init)))
    KEEP (*(.text.start))
  } >ram

  /* the bulk of the program: main, libc, functions etc. */
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)
    *(.text.exit .text.exit.*)
    *(.text.startup .text.startup.*)
    *(.text.hot .text.hot.*)
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  } >ram

  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);

  /* read-only sections coallesced together */
  .rodata         :
  {
    *(.rodata .rodata.* .gnu.linkonce.r.*)
    *(.rodata1)
  } >ram

  /* gcc language agnostic exception related sections (try-catch-finally) */
  .eh_frame_hdr :
  {
    *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*)
  } >ram
  .eh_frame :
  {
    KEEP (*(.eh_frame)) *(.eh_frame.*)
  } >ram
  .gnu_extab :
  {
    *(.gnu_extab*)
  } >ram
  .gcc_except_table :
  {
    *(.gcc_except_table .gcc_except_table.*)
  } >ram

  /* initialization and termination routines.  These are lookup tables, so go
     in the data section. */
  .preinit_array :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  } >ram
  .init_array     :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*)
    	    SORT_BY_INIT_PRIORITY(.ctors.*)))
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o
                                      *crtend?.o )
	    .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  } >ram
  .fini_array     :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*)
            SORT_BY_INIT_PRIORITY(.dtors.*)))
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o
                                      *crtend?.o )
	    .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } >ram
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP (*crtbegin.o(.ctors))
    KEEP (*crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  } >ram
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*crtbegin?.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
  } >ram

  /* data sections for initalized data */
  .data           :
  {
    __DATA_BEGIN__ = .;
    *(.data .data.* .gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
  } >ram
  .data1          :
  {
    *(.data1)
  } >ram

  /* We want the small data sections together, so single-instruction offsets
     can access them all, and initialized data all before uninitialized, so
     we can shorten the on-disk segment size.  */
  .sdata          :
  {
    __SDATA_BEGIN__ = .;
    *(.srodata.cst16) *(.srodata.cst8) *(.srodata.cst4) *(.srodata.cst2) *(.srodata .srodata.*)
    *(.sdata .sdata.* .gnu.linkonce.s.*)
  } >ram
  _edata = .;
  PROVIDE (edata = .);
  . = .;

  /* zero initialized sections */
  __bss_start = .;
  .sbss           :
  {
    *(.dynsbss)
    *(.sbss .sbss.* .gnu.linkonce.sb.*)
    *(.scommon)
  } >ram
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.*)
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we don't
      pad the .data section.  */
   . = ALIGN(. != 0 ? 32 / 8 : 1);
  } >ram
  . = ALIGN(32 / 8);
  . = SEGMENT_START("ldata-segment", .);
  . = ALIGN(32 / 8);
  __BSS_END__ = .;
  __bss_end = .;
  _end = .;
  PROVIDE (end = .);

  /* The compiler uses this to access data in the .sdata, .data, .sbss and .bss
     sections with fewer instructions (relaxation). This reduces code size. */
  __global_pointer$ = MIN(__SDATA_BEGIN__ + 0x800,
          MAX(__DATA_BEGIN__ + 0x800, __BSS_END__ - 0x800));

  /* Divide the remaining data RAM into heap (at the bottom) and stack (at the
     top).  All that matters is stack size.  Everthing else we can work
     out. We are making a (fairly sane) assumption that the top of data RAM is
     16 byte aligned for the stack. Note that the top of RAM is the first
     address that is *not* accessible, so we need to set the stack pointer
     back 16 bytes.

     FIXME:  However there is also a bug in X-Heep sbrk implementation,
     causing it to run off the end of the heap, which breaks Wikisort.  So we
     provide 0x100 bytes buffer. */
  __stack_size = DEFINED(__stack_size) ? __stack_size : 0x800;
  PROVIDE(__stack_size = __stack_size);
  __heap_size = LENGTH(ram) - _end - __stack_size - 0x100;

  /* heap: we should consider putting this to the bottom of the address space */
  .heap          :
  {
   PROVIDE(__heap_start = .);
   . = __heap_size;
   PROVIDE(__heap_end = .);
  } >ram

  /* stack: we should consider putting this further to the top of the address
    space */
  .stack         : ALIGN(16) /* this is a requirement of the ABI(?) */
  {
   PROVIDE(__stack_start = .);
   . = __stack_size;
   PROVIDE(_sp = .);
   PROVIDE(__stack_end = .);
   PROVIDE(__freertos_irq_stack_top = .);
  } >ram

  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end ) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF Extension.  */
  .debug_macro    0 : { *(.debug_macro) }
  .debug_addr     0 : { *(.debug_addr) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
}
